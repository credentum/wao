# The HyperBEAM Book (Pre-Release)

![](/images/book.jpg)

**From Zero to Building Custom Devices**

This book teaches you to build on HyperBEAM — the OS for the verifiable internet. Start with the foundation, learn Erlang, then work through the codebase from core resolution to device implementation. By the end, you'll understand every module and be ready to build.

:::warning
This book is in early development. Content may be incomplete or change without notice.
:::

:::note[About This Book]
Written for [HyperBEAM v0.9-milestone-3-beta-3](https://github.com/permaweb/HyperBEAM/releases/tag/v0.9-milestone-3-beta-3). Every chapter has a hands-on tutorial, and each module links to its full API reference.
:::

---

## Contents

0. [HyperBEAM](#prologue-hyperbeam)
1. [Setup](#chapter-1-setup)
2. [Erlang](#chapter-2-erlang)
3. [Project Structure](#chapter-3-project-structure)
4. [Arweave Utils](#chapter-4-arweave-utils)
5. [HyperBEAM Core](#chapter-5-hyperbeam-core)
6. [Devices](#chapter-6-devices)
7. [Building Your Own Devices](#chapter-7-building-your-own-devices)

---

## Prologue: HyperBEAM

The foundation of the AI era: the verifiable internet. AO-Core extends HTTP with verifiability. HyperBEAM is the OS. Learn the stack (messages, devices, processes, hashpath, attestation), then what you can build on top.

:::tip
[HyperBEAM](/book/hyperbeam)
:::

---

## Chapter 1: Setup

Get HyperBEAM running on your machine.

:::tip
[Setup Tutorial](/book/setup)
:::

---

## Chapter 2: Erlang

HyperBEAM is written in Erlang. You cannot read the code without learning the language first.

:::tip
[Erlang Crash Course Tutorial](/book/erlang)
:::

---

## Chapter 3: Project Structure

Before reading modules, understand how the codebase is organized.

:::tip
[Project Structure Tutorial](/book/structure)
:::

---

## Chapter 4: Arweave Utils

Arweave blockchain primitives. HyperBEAM stores everything on Arweave—these modules are the foundation.

:::tip
[Arweave Utils Tutorial](/book/ar)
:::

| Module | Description |
|--------|-------------|
| [rsa_pss](/src/rsa_pss) | RSA-PSS signature algorithm per RFC 3447, used by ar_wallet for all cryptographic operations |
| [ar_wallet](/src/ar_wallet) | Generates RSA-4096 keypairs, loads JWK keyfiles, signs data, verifies signatures, derives addresses |
| [ar_deep_hash](/src/ar_deep_hash) | Computes Arweave's recursive SHA-384 hash for transaction and data item ID generation |
| [ar_bundles](/src/ar_bundles) | Creates, signs, serializes, and deserializes ANS-104 data items and bundles |
| [ar_tx](/src/ar_tx) | Handles Layer 1 Arweave transactions including creation, signing, and serialization |
| [ar_timestamp](/src/ar_timestamp) | Fetches current block height and timestamp from Arweave network for time synchronization |
| [ar_rate_limiter](/src/ar_rate_limiter) | Token bucket rate limiter to prevent overwhelming Arweave gateways with requests |

---

## Chapter 5: HyperBEAM Core

The runtime environment that devices execute in. Understanding these modules helps you write better devices and debug issues.

You'll start with pure utilities, then learn how data flows through the system — from configuration to storage to network to the protocol that ties everything together.

---

### 1. Utilities

Pure helper functions used throughout the codebase.

:::tip
[Utilities Tutorial](/book/hb1)
:::

| Module | Description |
|--------|-------------|
| [hb_util](/src/hb_util) | Base64url encoding, unique ID generation, type coercion, and debug printing utilities |
| [hb_json](/src/hb_json) | JSON encoding and decoding wrapper supporting maps, lists, binaries, and primitives |
| [hb_escape](/src/hb_escape) | URI percent-encoding, path segment escaping, and safe string handling |
| [hb_structured_fields](/src/hb_structured_fields) | RFC 9651 HTTP Structured Fields parser for dictionaries, lists, and typed values |
| [hb_keccak](/src/hb_keccak) | Keccak-256 hashing via NIF, also derives Ethereum addresses from public keys |
| [hb_crypto](/src/hb_crypto) | Multi-algorithm signing helpers for RSA, ECDSA, Ed25519 with format conversion |

---

### 2. Configuration

How HyperBEAM settings flow from defaults through node config to per-message overrides.

:::tip
[Configuration Tutorial](/book/hb2)
:::

| Module | Description |
|--------|-------------|
| [hb_opts](/src/hb_opts) | Hierarchical configuration resolving options from message to node config to defaults |
| [hb_private](/src/hb_private) | Manages private keys and signing context, keeps secrets out of cached data |
| [hb_features](/src/hb_features) | Feature flag system for enabling/disabling functionality and gradual rollouts |
| [hb_path](/src/hb_path) | Parses paths into segments, matches patterns with wildcards, handles templates |

---

### 3. Data Structures

Messages are maps. These modules define how they're created, signed, linked, and transformed.

:::tip
[Data Structures Tutorial](/book/hb3)
:::

| Module | Description |
|--------|-------------|
| [hb_maps](/src/hb_maps) | Enhanced map operations with automatic link resolution and nested path traversal |
| [hb_message](/src/hb_message) | Creates messages, computes IDs, signs with attestations, verifies signatures |
| [hb_link](/src/hb_link) | Content-addressed references that resolve through cache with hashpath computation |
| [hb_singleton](/src/hb_singleton) | Converts between flat path-based keys and nested hierarchical message formats |

---

### 4. Storage

Persistent data storage with pluggable backends.

:::tip
[Storage Tutorial](/book/hb4)
:::

| Module | Description |
|--------|-------------|
| [hb_store](/src/hb_store) | Abstract storage interface defining read, write, list, delete operations |
| [hb_store_opts](/src/hb_store_opts) | Parses store configuration and creates store instances with fallback chains |
| [hb_store_fs](/src/hb_store_fs) | Filesystem storage backend that stores data as files in directories |
| [hb_store_lmdb](/src/hb_store_lmdb) | LMDB backend via NIF—fast, reliable, default storage with concurrent readers |
| [hb_store_rocksdb](/src/hb_store_rocksdb) | RocksDB LSM-tree backend via NIF for write-heavy workloads |
| [hb_store_lru](/src/hb_store_lru) | Wraps any store with in-memory LRU cache for improved read performance |

---

### 5. Caching

Content-addressed caching layer on top of storage.

:::tip
[Caching Tutorial](/book/hb5)
:::

| Module | Description |
|--------|-------------|
| [hb_cache](/src/hb_cache) | Stores messages by content hash, resolves links recursively, expands nested messages |
| [hb_cache_control](/src/hb_cache_control) | Parses HTTP Cache-Control headers and determines cacheability of responses |

---

### 6. HTTP Client

Outbound HTTP requests to gateways and other nodes.

:::tip
[HTTP Client Tutorial](/book/hb6)
:::

| Module | Description |
|--------|-------------|
| [hb_http_client](/src/hb_http_client) | HTTP client wrapper managing Gun connections with pooling and retries |
| [hb_http_client_sup](/src/hb_http_client_sup) | Supervisor for HTTP client connection pools handling lifecycle and restarts |
| [hb_http_multi](/src/hb_http_multi) | Sends parallel requests to multiple nodes and aggregates results |
| [hb_http](/src/hb_http) | Convenience GET/POST helpers with codec negotiation and response parsing |
| [hb_gateway_client](/src/hb_gateway_client) | Arweave gateway API client for fetching transactions, data, and blocks |
| [hb_client](/src/hb_client) | High-level Arweave client combining gateway operations for common tasks |
| [hb_router](/src/hb_router) | Selects which nodes to contact based on health checks and routing preferences |

---

### 7. Remote Storage

Storage backends that fetch data over the network.

:::tip
[Remote Storage Tutorial](/book/hb7)
:::

| Module | Description |
|--------|-------------|
| [hb_store_gateway](/src/hb_store_gateway) | Fetches data from Arweave gateway on cache miss, read-only remote storage |
| [hb_store_remote_node](/src/hb_store_remote_node) | Fetches data from other HyperBEAM nodes enabling distributed storage |

---

### 8. Protocol

The heart of HyperBEAM. Every request flows through `hb_ao:resolve/3`.

:::tip
[Protocol Tutorial](/book/hb8)
:::

| Module | Description |
|--------|-------------|
| [hb_ao](/src/hb_ao) | Core protocol implementing resolve/3 that routes every request to devices |
| [hb_ao_device](/src/hb_ao_device) | Loads device modules by name, caches them, dispatches calls to handlers |

---

### 9. HTTP Server

Inbound HTTP handling.

:::tip
[HTTP Server Tutorial](/book/hb9)
:::

| Module | Description |
|--------|-------------|
| [hb_http_server](/src/hb_http_server) | Cowboy handlers routing HTTP requests to hb_ao with codec negotiation |

---

### 10. WASM

WebAssembly execution environment.

:::tip
[WASM Tutorial](/book/hb10)
:::

| Module | Description |
|--------|-------------|
| [hb_beamr](/src/hb_beamr) | WASM runtime interface via WAMR, manages module loading and execution |
| [hb_beamr_io](/src/hb_beamr_io) | Provides I/O primitives to WASM modules including stdin/stdout and files |

---

### 11. Application

OTP application structure and node lifecycle.

:::tip
[Application Tutorial](/book/hb11)
:::

| Module | Description |
|--------|-------------|
| [hb_name](/src/hb_name) | Registers and looks up Erlang processes by name within the node |
| [hb_persistent](/src/hb_persistent) | Stores process state durably to survive restarts with consistency guarantees |
| [hb_sup](/src/hb_sup) | Main supervisor defining the supervision tree and restart strategies |
| [hb_app](/src/hb_app) | OTP application behavior with start/stop callbacks and initialization |
| [hb](/src/hb) | Top-level API for starting/stopping nodes and convenience functions |

---

### Supplemental

:::note
These modules are not directly related to building devices. They cover node operations, debugging, and testing infrastructure.
:::

#### Volume

Storage partitions and data routing.

| Module | Description |
|--------|-------------|
| [hb_volume](/src/hb_volume) | Manages storage partitions, handles mounting/unmounting and data routing |

#### Monitoring

Logging, tracing, debugging, and metrics.

| Module | Description |
|--------|-------------|
| [hb_format](/src/hb_format) | Pretty-prints messages, stack traces, and binaries for debugging output |
| [hb_event](/src/hb_event) | Defines ?event macro for structured logging with levels and context |
| [hb_logger](/src/hb_logger) | Formats log events and routes to console/file with rotation support |
| [hb_tracer](/src/hb_tracer) | Records message flow through devices with trace IDs and timing data |
| [hb_debugger](/src/hb_debugger) | Interactive step debugger for device execution with state inspection |
| [hb_cache_render](/src/hb_cache_render) | Generates DOT/GraphViz graphs showing cache contents and relationships |
| [hb_metrics_collector](/src/hb_metrics_collector) | Collects and exposes Prometheus metrics for request counts and latencies |
| [hb_process_monitor](/src/hb_process_monitor) | Monitors Erlang process health, detects failures, reports status |

#### Testing

Test utilities and conformance tests.

| Module | Description |
|--------|-------------|
| [hb_test_utils](/src/hb_test_utils) | Common test fixtures, assertion helpers, and mock setup utilities |
| [hb_ao_test_vectors](/src/hb_ao_test_vectors) | Protocol conformance test vectors ensuring hb_ao compatibility |
| [hb_message_test_vectors](/src/hb_message_test_vectors) | Test vectors for message creation, signing, and ID computation |
| [hb_http_benchmark_tests](/src/hb_http_benchmark_tests) | Performance benchmarks measuring throughput and latency distributions |
| [hb_examples](/src/hb_examples) | Usage examples demonstrating common patterns and best practices |

---

## Chapter 6: Devices

Built-in devices implementing AO-Core protocol behaviors.

---

### 1. Messages & Composition

The foundational device and composition patterns.

:::tip
[Messages & Composition Tutorial](/book/dev1)
:::

| Module | Description |
|--------|-------------|
| [dev_message](/src/dev_message) | Core device implementing get, set, keys, remove—the foundation of all devices |
| [dev_stack](/src/dev_stack) | Chains devices into ordered execution pipelines with Fold and Map modes |
| [dev_multipass](/src/dev_multipass) | Runs message through stack multiple times until stable or limit |
| [dev_apply](/src/dev_apply) | Dynamic path execution with base:/request: prefixes |
| [dev_patch](/src/dev_patch) | Moving data between message paths |
| [dev_dedup](/src/dev_dedup) | Prevents duplicate message processing with configurable detection |

---

### 2. Codecs

Message encoding, decoding, and cryptographic signing.

:::tip
[Codecs Tutorial](/book/dev2)
:::

| Module | Description |
|--------|-------------|
| [dev_codec_httpsig](/src/dev_codec_httpsig) | HTTP Message Signatures (RFC 9421) |
| ↳ [dev_codec_httpsig_conv](/src/dev_codec_httpsig_conv) | Conversions for signature components |
| ↳ [dev_codec_httpsig_keyid](/src/dev_codec_httpsig_keyid) | Key ID management |
| ↳ [dev_codec_httpsig_proxy](/src/dev_codec_httpsig_proxy) | Proxy support for signature forwarding |
| ↳ [dev_codec_httpsig_siginfo](/src/dev_codec_httpsig_siginfo) | Signature metadata extraction |
| [dev_codec_structured](/src/dev_codec_structured) | RFC 9651 Structured Fields with ao-types annotations |
| [dev_codec_json](/src/dev_codec_json) | JSON encoding/decoding for HTTP APIs |
| [dev_codec_flat](/src/dev_codec_flat) | Path-based flat map encoding for configuration |

---

### 3. Infrastructure

Node configuration, routing, and lifecycle management.

:::tip
[Infrastructure Tutorial](/book/dev3)
:::

| Module | Description |
|--------|-------------|
| [dev_meta](/src/dev_meta) | Node configuration, initialization, and request handling |
| [dev_router](/src/dev_router) | Message routing with load balancing strategies |
| [dev_relay](/src/dev_relay) | Synchronous and asynchronous message relay between nodes |
| [dev_node_process](/src/dev_node_process) | Singleton process management for node services |
| [dev_hook](/src/dev_hook) | Lifecycle hooks for request/response processing |
| [dev_manifest](/src/dev_manifest) | Defines process configuration—device stack, scheduler, compute limits |

---

### 4. Process & Scheduling

Stateful computation units and deterministic message ordering.

:::tip
[Process & Scheduling Tutorial](/book/dev4)
:::

| Module | Description |
|--------|-------------|
| [dev_process](/src/dev_process) | Core AO process execution coordinator |
| ↳ [dev_process_cache](/src/dev_process_cache) | Caches computed process states |
| ↳ [dev_process_worker](/src/dev_process_worker) | Worker pools for parallel execution |
| [dev_scheduler](/src/dev_scheduler) | Message ordering and slot assignment |
| ↳ [dev_scheduler_cache](/src/dev_scheduler_cache) | Caches scheduler assignments |
| ↳ [dev_scheduler_formats](/src/dev_scheduler_formats) | Format version handling |
| ↳ [dev_scheduler_registry](/src/dev_scheduler_registry) | Process registration and discovery |
| ↳ [dev_scheduler_server](/src/dev_scheduler_server) | Long-running server process |
| [dev_push](/src/dev_push) | Recursive message delivery between processes |
| [dev_cron](/src/dev_cron) | Time-based scheduled execution with cron expressions |

---

### 5. Storage & Naming

Data persistence and name resolution.

:::tip
[Storage & Naming Tutorial](/book/dev5)
:::

| Module | Description |
|--------|-------------|
| [dev_cache](/src/dev_cache) | Read/write data with access control |
| [dev_lookup](/src/dev_lookup) | Retrieve resources by ID with format negotiation |
| [dev_local_name](/src/dev_local_name) | Register human-readable names for resources |
| [dev_name](/src/dev_name) | Resolve names through configurable resolver chains |

---

### 6. Runtimes

Code execution environments—WASM, Lua, delegated compute.

:::tip
[Runtimes Tutorial](/book/dev6)
:::

| Module | Description |
|--------|-------------|
| [dev_wasm](/src/dev_wasm) | Execute WebAssembly with Memory-64 support |
| ↳ [dev_wasi](/src/dev_wasi) | Virtual filesystem for WASM programs |
| ↳ [dev_json_iface](/src/dev_json_iface) | JSON interface for WASM modules |
| ↳ [dev_genesis_wasm](/src/dev_genesis_wasm) | Initial WASM module configuration |
| [dev_lua](/src/dev_lua) | Run Lua scripts in sandboxed VMs |
| ↳ [dev_lua_lib](/src/dev_lua_lib) | HyperBEAM API bindings for Lua |
| [dev_cu](/src/dev_cu) | Delegate to external Compute Units |
| ↳ [dev_delegated_compute](/src/dev_delegated_compute) | Remote computation with verification |

---

### 7. Payment

Pricing and payment in HyperBEAM.

:::tip
[Payment Tutorial](/book/dev7)
:::

| Module | Description |
|--------|-------------|
| [dev_p4](/src/dev_p4) | Core payment ledger and pricing orchestrator |
| [dev_simple_pay](/src/dev_simple_pay) | Per-request pricing with balance management |
| [dev_faff](/src/dev_faff) | Allow-list based access control |

---

### 8. Authentication

Identity and signatures.

:::tip
[Authentication Tutorial](/book/dev8)
:::

| Module | Description |
|--------|-------------|
| [dev_auth_hook](/src/dev_auth_hook) | Automatic request signing with node-hosted wallets |
| [dev_codec_http_auth](/src/dev_codec_http_auth) | HTTP Basic authentication with PBKDF2 |
| [dev_codec_cookie](/src/dev_codec_cookie) | Cookie management and storage |
| ↳ [dev_codec_cookie_auth](/src/dev_codec_cookie_auth) | Cookie-based HMAC authentication |
| [dev_secret](/src/dev_secret) | Secret key management device |

---

### 9. Arweave & Data

Permanent storage and data retrieval.

:::tip
[Arweave & Data Tutorial](/book/dev9)
:::

| Module | Description |
|--------|-------------|
| [dev_arweave](/src/dev_arweave) | Arweave network interface |
| ↳ [dev_arweave_block_cache](/src/dev_arweave_block_cache) | Caches Arweave blocks locally |
| [dev_codec_ans104](/src/dev_codec_ans104) | ANS-104 data item codec |
| ↳ [dev_codec_ans104_from](/src/dev_codec_ans104_from) | Decode ANS-104 to messages |
| ↳ [dev_codec_ans104_to](/src/dev_codec_ans104_to) | Encode messages to ANS-104 |
| [dev_query](/src/dev_query) | Cache search and discovery |
| ↳ [dev_query_arweave](/src/dev_query_arweave) | Arweave gateway GraphQL |
| ↳ [dev_query_graphql](/src/dev_query_graphql) | GraphQL query executor |
| [dev_copycat](/src/dev_copycat) | Message indexing from external sources |
| ↳ [dev_copycat_arweave](/src/dev_copycat_arweave) | Replicate from Arweave |
| ↳ [dev_copycat_graphql](/src/dev_copycat_graphql) | GraphQL-based discovery |
| [dev_poda](/src/dev_poda) | Generates and verifies proofs that data exists on Arweave |

---

### Supplemental Devices

:::note
Additional devices for security, debugging, and testing.
:::

#### Security & TEE

| Module | Description |
|--------|-------------|
| [dev_volume](/src/dev_volume) | Volume device for mounting, unmounting, and listing storage volumes |
| [dev_snp](/src/dev_snp) | AMD SEV-SNP attestation for TEE |
| ↳ [dev_snp_nif](/src/dev_snp_nif) | Native C interface for SNP |
| [dev_green_zone](/src/dev_green_zone) | Defines security boundaries for sensitive operations requiring TEE |

#### Utilities & Debugging

| Module | Description |
|--------|-------------|
| [dev_trie](/src/dev_trie) | Prefix tree implementation for efficient key lookup |
| [dev_profile](/src/dev_profile) | Records execution timing and memory allocation |
| [dev_hyperbuddy](/src/dev_hyperbuddy) | Web-based interactive debugging UI |
| [dev_cacheviz](/src/dev_cacheviz) | Generates visual representation of cache contents |
| [dev_whois](/src/dev_whois) | Looks up node information by address |
| [dev_monitor](/src/dev_monitor) | Tracks system health with alerting |
| [dev_test](/src/dev_test) | Test device with configurable responses |

#### Test Vectors

| Module | Description |
|--------|-------------|
| ↳ [dev_codec_cookie_test_vectors](/src/dev_codec_cookie_test_vectors) | Cookie parsing conformance tests |
| ↳ [dev_query_test_vectors](/src/dev_query_test_vectors) | Query device behavior tests |
| ↳ [dev_lua_test](/src/dev_lua_test) | Lua runtime integration tests |
| ↳ [dev_lua_test_ledgers](/src/dev_lua_test_ledgers) | Lua ledger operation tests |

---

## Chapter 7: Building Your Own Devices

Now that you understand the codebase, build your own devices.

:::info[Tutorial Coming Soon]
*Building Devices Overview*
:::

| Tutorial | Description |
|----------|-------------|
| [Custom Devices in Erlang](/tutorials/creating-devices) | Native Erlang devices with full HyperBEAM integration |
| [Custom Devices in Rust](/tutorials/devices-rust) | High-performance NIFs for compute-intensive operations |
| [Custom Devices in C++](/tutorials/devices-cpp) | Native implementations with direct memory access |

---

## Resources

- [Official Documentation](https://hyperbeam.ar.io/)
- [GitHub Repository](https://github.com/permaweb/HyperBEAM)
- [Decoding HyperBEAM from Scratch](https://docs.wao.eco/hyperbeam/decoding-from-scratch)