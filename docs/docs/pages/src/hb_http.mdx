# hb_http.erl - HyperBEAM HTTP Request/Reply Core

## Overview

**Purpose:** Core HTTP request/reply functionality for HyperBEAM  
**Module:** `hb_http`  
**Protocol:** HTTP/HTTPS with message-based communication  
**Pattern:** Message request → HTTP → Message response

This module provides HyperBEAM's primary HTTP functionality, converting messages to HTTP requests and processing responses back into message form. It handles both client requests (GET, POST) and server-side request processing, supporting multiple codec devices and serialization formats.

## Core Responsibilities

- **Client Requests:** GET/POST operations to remote nodes
- **Message Conversion:** Transform HyperBEAM messages to/from HTTP
- **Codec Support:** Handle `httpsig@1.0`, `ans104@1.0`, and structured messages
- **Cookie Management:** Parse and normalize Set-Cookie headers
- **Response Processing:** Convert HTTP responses to appropriate message formats
- **Multi-Request:** Delegate to `hb_http_multi` for route-based requests

## Dependencies

- **HyperBEAM:** `hb_ao`, `hb_message`, `hb_util`, `hb_maps`, `hb_opts`, `hb_json`, `hb_singleton`
- **Codecs:** `dev_codec_ans104`, `dev_codec_structured`, `dev_codec_cookie`, `dev_codec_httpsig`
- **HTTP Client:** `hb_http_client`, `hb_http_multi`
- **Arweave:** `ar_bundles`, `ar_wallet`
- **External:** `cowboy_req`, `httpc`
- **Includes:** `include/hb.hrl`

---

## Public Functions Overview

```erlang
%% Initialization
-spec start() -> ok.

%% Client Requests
-spec get(Node, Opts) -> {ok, Message} | {error, Reason}.
-spec get(Node, Path, Opts) -> {ok, Message} | {error, Reason}.
-spec get(Node, Message, Opts) -> {ok, Message} | {error, Reason}.

-spec post(Node, Path, Opts) -> {ok, Message} | {error, Reason}.
-spec post(Node, Message, Opts) -> {ok, Message} | {error, Reason}.
-spec post(Node, Path, Message, Opts) -> {ok, Message} | {error, Reason}.

%% Generic Request
-spec request(Message, Opts) -> {ok | created | error | failure, Result}.
-spec request(Method, Peer, Path, Opts) -> {ok | created | error | failure, Result}.
-spec request(Method, Peer, Path, Message, Opts) -> {ok | created | error | failure, Result}.

%% Message Conversion
-spec message_to_request(Message, Opts) -> {ok, Method, Peer, Path, Message, Opts}.

%% Server Processing
-spec reply(Request, StatusCode, Headers, Body) -> cowboy_req:req().
-spec accept_to_codec(Accept, Opts) -> CodecDevice.

%% Utilities
-spec req_to_tabm_singleton(Request, Message, Opts) -> Messages.
```

---

## Public Functions

### 1. start/0

```erlang
-spec start() -> ok.
```

**Description:** Initialize HTTP client by disabling keep-alive connections.

**Implementation:**
```erlang
start() ->
    httpc:set_options([{max_keep_alive_length, 0}]),
    ok.
```

---

### 2. get/2, get/3

```erlang
-spec get(Node, Opts) -> {ok, Message} | {error, Reason}
    when
        Node :: binary(),
        Opts :: map(),
        Message :: map(),
        Reason :: term().

-spec get(Node, PathOrMessage, Opts) -> {ok, Message} | {error, Reason}
    when
        Node :: binary(),
        PathOrMessage :: binary() | map(),
        Opts :: map(),
        Message :: map(),
        Reason :: term().
```

**Description:** Perform HTTP GET request to a remote node, returning deserialized message response.

**Test Code:**
```erlang
-module(hb_http_get_test).
-include_lib("eunit/include/eunit.hrl").

get_basic_test() ->
    URL = hb_http_server:start_node(),
    {ok, Res} = hb_http:get(URL, <<"/~meta@1.0/info">>, #{}),
    ?assert(is_map(Res)).

get_with_message_test() ->
    URL = hb_http_server:start_node(),
    Message = #{<<"path">> => <<"/key1">>, <<"key1">> => <<"Value1">>},
    {ok, Res} = hb_http:get(URL, Message, #{}),
    ?assert(is_map(Res)).

cors_get_test() ->
    URL = hb_http_server:start_node(),
    {ok, Res} = hb_http:get(URL, <<"/~meta@1.0/info">>, #{}),
    ?assertEqual(<<"*">>, hb_ao:get(<<"access-control-allow-origin">>, Res, #{})).
```

---

### 3. post/3, post/4

```erlang
-spec post(Node, PathOrMessage, Opts) -> {ok, Message} | {error, Reason}
    when
        Node :: binary(),
        PathOrMessage :: binary() | map(),
        Opts :: map(),
        Message :: map(),
        Reason :: term().

-spec post(Node, Path, Message, Opts) -> {ok, Message} | {error, Reason}
    when
        Node :: binary(),
        Path :: binary(),
        Message :: map(),
        Opts :: map(),
        Reason :: term().
```

**Description:** Post message to remote node via HTTP, returning deserialized response.

**Test Code:**
```erlang
-module(hb_http_post_test).
-include_lib("eunit/include/eunit.hrl").

simple_ao_resolve_unsigned_test() ->
    URL = hb_http_server:start_node(),
    TestMsg = #{<<"path">> => <<"/key1">>, <<"key1">> => <<"Value1">>},
    ?assertEqual({ok, <<"Value1">>}, hb_http:post(URL, TestMsg, #{})).

simple_ao_resolve_signed_test() ->
    URL = hb_http_server:start_node(),
    TestMsg = #{<<"path">> => <<"/key1">>, <<"key1">> => <<"Value1">>},
    Wallet = hb:wallet(),
    {ok, Res} = hb_http:post(URL, hb_message:commit(TestMsg, Wallet), #{}),
    ?assertEqual(<<"Value1">>, Res).

nested_ao_resolve_test() ->
    URL = hb_http_server:start_node(),
    Wallet = hb:wallet(),
    {ok, Res} = hb_http:post(
        URL,
        hb_message:commit(#{
            <<"path">> => <<"/key1/key2/key3">>,
            <<"key1">> => #{<<"key2">> => #{<<"key3">> => <<"Value2">>}}
        }, Wallet),
        #{}
    ),
    ?assertEqual(<<"Value2">>, Res).
```

---

### 4. request/2, request/4, request/5

```erlang
-spec request(Message, Opts) -> {Status, Result}
    when
        Message :: map(),
        Opts :: map(),
        Status :: ok | created | error | failure,
        Result :: term().

-spec request(Method, Peer, Path, Message, Opts) -> {Status, Result}
    when
        Method :: binary(),
        Peer :: binary() | map(),
        Path :: binary(),
        Message :: map(),
        Opts :: map(),
        Status :: ok | created | error | failure,
        Result :: term().
```

**Description:** Generic HTTP request handler supporting GET, POST, PUT, DELETE. Handles routing, multi-requests, codec selection, and response processing.

**Special Cases:**
- **Routes:** Delegates to `hb_http_multi` when `<<"nodes">>` present
- **URI Options:** Merges additional options from route configuration
- **AO-Result:** Returns single key value when `ao-result` header present

**Test Code:**
```erlang
-module(hb_http_request_test).
-include_lib("eunit/include/eunit.hrl").

run_wasm_unsigned_test() ->
    Node = hb_http_server:start_node(#{force_signed => false}),
    {ok, Bin} = file:read_file(<<"test/test-64.wasm">>),
    Msg = #{
        <<"path">> => <<"/init/compute/results">>,
        <<"device">> => <<"wasm-64@1.0">>,
        <<"function">> => <<"fac">>,
        <<"parameters">> => [3.0],
        <<"body">> => Bin
    },
    {ok, Res} = hb_http:post(Node, Msg, #{}),
    ?assertEqual(6.0, hb_ao:get(<<"output/1">>, Res, #{})).

run_wasm_signed_test() ->
    Opts = #{priv_wallet => hb:wallet()},
    URL = hb_http_server:start_node(#{force_signed => true}),
    {ok, Bin} = file:read_file(<<"test/test-64.wasm">>),
    Msg = hb_message:commit(#{
        <<"device">> => <<"wasm-64@1.0">>,
        <<"function">> => <<"fac">>,
        <<"parameters">> => [3.0],
        <<"body">> => Bin
    }, Opts),
    {ok, Res} = hb_http:post(URL, Msg#{ <<"path">> => <<"/init/compute/results">> }, Opts),
    ?assertEqual(6.0, hb_ao:get(<<"output/1">>, Res, #{})).

ans104_wasm_test() ->
    ClientOpts = #{store => [hb_test_utils:test_store()], priv_wallet => hb:wallet()},
    URL = hb_http_server:start_node(#{force_signed => true}),
    {ok, Bin} = file:read_file(<<"test/test-64.wasm">>),
    Msg = hb_message:commit(
        #{
            <<"require-codec">> => <<"ans104@1.0">>,
            <<"codec-device">> => <<"ans104@1.0">>,
            <<"device">> => <<"wasm-64@1.0">>,
            <<"function">> => <<"fac">>,
            <<"parameters">> => [3.0],
            <<"body">> => Bin
        },
        ClientOpts,
        #{<<"device">> => <<"ans104@1.0">>, <<"bundle">> => true}
    ),
    {ok, Res} = hb_http:post(URL, Msg#{<<"path">> => <<"/init/compute/results">>}, ClientOpts),
    ?assertEqual(6.0, hb_ao:get(<<"output/1">>, Res, ClientOpts)).
```

---

### 5. message_to_request/2

```erlang
-spec message_to_request(Message, Opts) -> {ok, Method, Peer, Path, Message, Opts}
    when
        Message :: map(),
        Opts :: map(),
        Method :: binary(),
        Peer :: binary(),
        Path :: binary().
```

**Description:** Convert HyperBEAM message to HTTP request components, extracting method, peer, path, and preparing message for transmission.

**Conversion Flow:**
```erlang
Message
    ↓
Extract Method (default: GET)
    ↓
Parse URL/Peer/Path
    ↓
Handle Query Parameters
    ↓
Prepare Message Body
    ↓
Return {ok, Method, Peer, Path, PreparedMessage, Opts}
```

---

### 6. reply/4

```erlang
-spec reply(Request, StatusCode, Headers, Body) -> cowboy_req:req()
    when
        Request :: cowboy_req:req(),
        StatusCode :: integer(),
        Headers :: map() | list(),
        Body :: binary().
```

**Description:** Send HTTP response to client via Cowboy, handling headers, status codes, and body serialization.

**Features:**
- Auto-detects content type from body
- Converts headers map to list format
- Handles binary and JSON bodies
- Sets appropriate CORS headers

---

### 7. accept_to_codec/2

```erlang
-spec accept_to_codec(Accept, Opts) -> CodecDevice
    when
        Accept :: binary() | undefined,
        CodecDevice :: binary().
```

**Description:** Convert HTTP Accept header to HyperBEAM codec device identifier.

**Mappings:**
```erlang
<<"application/octet-stream">> -> <<"ans104@1.0">>
<<"application/json">>         -> <<"structured@1.0">>
<<"text/plain">>               -> <<"structured@1.0">>
undefined                      -> <<"structured@1.0">>
```

---

### 8. req_to_tabm_singleton/3

```erlang
-spec req_to_tabm_singleton(Request, Message, Opts) -> Messages
    when
        Request :: cowboy_req:req(),
        Message :: map(),
        Opts :: map(),
        Messages :: [map()].
```

**Description:** Convert Cowboy request to HyperBEAM message sequence for singleton execution.

**Processing Steps:**
1. Extract HTTP method and path
2. Parse query parameters
3. Extract and normalize headers
4. Handle cookie parsing
5. Process request body based on content-type
6. Detect codec device from Accept header
7. Add peer information if `ao-peer-port` present

---

## Response Status Mapping

```erlang
response_status_to_atom(Status) ->
    case Status of
        201 -> created;
        X when X < 400 -> ok;
        X when X < 500 -> error;
        _ -> failure
    end.
```

**Status Categories:**
- `created` - HTTP 201
- `ok` - HTTP 2xx-3xx (except 201)
- `error` - HTTP 4xx (client errors)
- `failure` - HTTP 5xx (server errors)

---

## Codec Device Handling

### Outbound Requests

```erlang
% Detect codec from message or use default
CodecDev = hb_maps:get(<<"codec-device">>, Message, <<"httpsig@1.0">>, Opts),

% Prepare request based on codec
prepare_request(CodecDev, Method, Peer, Path, Message, Opts)
```

### Inbound Responses

```erlang
% Find codec from response headers
CodecDev = hb_maps:get(<<"codec-device">>, Headers, <<"httpsig@1.0">>, Opts),

% Convert response to message
outbound_result_to_message(CodecDev, Status, Headers, Body, Opts)
```

**Supported Codecs:**
- `httpsig@1.0` - HTTP Signature (default)
- `ans104@1.0` - ANS-104 data items
- `structured@1.0` - Structured messages
- `json@1.0` - JSON encoding

---

## Cookie Handling

### Set-Cookie Processing

```erlang
% Extract Set-Cookie headers from response
SetCookieLines = [{<<"set-cookie">>, KeyVal} || {<<"set-cookie">>, KeyVal} <- Headers],

% Convert to cookie message
{ok, MsgWithCookies} = dev_codec_cookie:from(
    #{<<"set-cookie">> => SetCookieLines},
    #{},
    Opts
),

% Merge into response headers
HeaderMap = hb_maps:merge(hb_maps:from_list(Headers), MsgWithCookies, Opts)
```

### Cookie Request Handling

```erlang
% Parse cookie from request
{ok, WithCookie} = case maps:get(<<"cookie">>, RawHeaders, undefined) of
    undefined -> {ok, BaseMsg};
    Cookie -> dev_codec_cookie:from(BaseMsg#{<<"cookie">> => Cookie}, Req, Opts)
end
```

---

## Common Patterns

```erlang
%% Simple GET request
{ok, Response} = hb_http:get(<<"http://node.example.com">>, <<"/path">>, #{}).

%% POST with message
Message = #{<<"key">> => <<"value">>},
{ok, Response} = hb_http:post(Node, <<"/endpoint">>, Message, #{}).

%% Signed POST request
Wallet = hb:wallet(),
SignedMsg = hb_message:commit(Message, #{priv_wallet => Wallet}),
{ok, Response} = hb_http:post(Node, SignedMsg, #{}).

%% Request with specific codec
Opts = #{<<"codec-device">> => <<"ans104@1.0">>},
{ok, Response} = hb_http:post(Node, Message, Opts).

%% Extract single result key
Opts = #{http_only_result => true},
Message = #{<<"path">> => <<"/data">>, <<"ao-result">> => <<"body">>},
{ok, BodyOnly} = hb_http:post(Node, Message, Opts).

%% Handle routes (multi-request)
Config = #{
    <<"nodes">> => [
        <<"http://node1.example.com">>,
        <<"http://node2.example.com">>
    ]
},
{ok, Response} = hb_http:request(<<"GET">>, Config, <<"/path">>, #{}, #{}).
```

---

## Configuration Options

```erlang
Opts = #{
    % HTTP client selection
    http_client => gun | httpc,  % Default: gun
    
    % Result extraction
    http_only_result => true | false,  % Default: true
    
    % Codec selection
    <<"codec-device">> => <<"httpsig@1.0">> | <<"ans104@1.0">> | <<"structured@1.0">>,
    
    % Wallet for signing
    priv_wallet => {PrivateKey, PublicKey},
    
    % Request timeout
    http_request_send_timeout => Milliseconds,
    
    % Response size limit
    limit => Bytes | infinity,
    
    % Peer identification
    is_peer_request => boolean(),
    
    % HTTP monitoring
    http_monitor => MonitorMessage,
    http_reference => ReferenceValue,
    
    % Cache control
    cache_control => [<<"no-cache">>, <<"no-store">>]
}.
```

---

## Error Handling

```erlang
% Client errors (4xx)
{error, Reason}

% Server errors (5xx)
{failure, Reason}

% Network errors
{error, client_error}
{error, connection_closed}
{error, timeout}

% Codec errors
{error, unsupported_codec}
{error, invalid_message}
```

---

## Server-Side Processing

### Request Normalization

```erlang
% Convert Cowboy request to HyperBEAM message
Messages = hb_http:req_to_tabm_singleton(Req, InitialMsg, Opts),

% Process through singleton
Results = hb_ao:resolve_many(Messages, Opts)
```

### Response Generation

```erlang
% Send response back to client
Reply = hb_http:reply(Req, 200, Headers, Body)
```

---

## Performance Notes

1. **Keep-Alive Disabled:** Connections don't persist between requests
2. **Parallel Requests:** Use `hb_http_multi` for concurrent node access
3. **Streaming:** Supports chunked transfer encoding via gun
4. **Metrics:** Records request duration in Prometheus when enabled
5. **Connection Pooling:** Managed by `hb_http_client` gen_server

---

## References

- **HTTP Client** - `hb_http_client.erl`
- **Multi-Request** - `hb_http_multi.erl`
- **Message System** - `hb_message.erl`, `hb_ao.erl`
- **Codecs** - `dev_codec_*.erl` modules
- **Server** - `hb_http_server.erl`

---

## Notes

1. **Default Codec:** `httpsig@1.0` used unless specified
2. **Message Signing:** Optional, controlled by wallet presence
3. **Cookie Support:** Full Set-Cookie and Cookie header processing
4. **CORS:** Automatic CORS headers on responses
5. **Query Parameters:** Extracted and added to message
6. **Path Resolution:** Supports nested path traversal in messages
7. **AO-Result:** Can extract single key from response for efficiency
8. **Peer Detection:** Honors `x-real-ip` for accurate peer address
9. **Body Streaming:** Large responses handled efficiently
10. **Status Normalization:** Consistent status atom mapping
11. **Multi-Gateway:** Seamless delegation to multi-request system
12. **Header Filtering:** Default filter for `content-length`
13. **Content-Type Detection:** Auto-detects from body or headers
14. **Accept Header:** Maps to appropriate codec device
15. **Monitoring:** Optional HTTP request monitoring via AO-Core# hb_http.erl - HyperBEAM HTTP Request/Reply Core

## Overview

**Purpose:** Core HTTP request/reply functionality for HyperBEAM  
**Module:** `hb_http`  
**Protocol:** HTTP/HTTPS with message-based communication  
**Pattern:** Message request → HTTP → Message response

This module provides HyperBEAM's primary HTTP functionality, converting messages to HTTP requests and processing responses back into message form. It handles both client requests (GET, POST) and server-side request processing, supporting multiple codec devices and serialization formats.

## Core Responsibilities

- **Client Requests:** GET/POST operations to remote nodes
- **Message Conversion:** Transform HyperBEAM messages to/from HTTP
- **Codec Support:** Handle `httpsig@1.0`, `ans104@1.0`, and structured messages
- **Cookie Management:** Parse and normalize Set-Cookie headers
- **Response Processing:** Convert HTTP responses to appropriate message formats
- **Multi-Request:** Delegate to `hb_http_multi` for route-based requests

## Dependencies

- **HyperBEAM:** `hb_ao`, `hb_message`, `hb_util`, `hb_maps`, `hb_opts`, `hb_json`, `hb_singleton`
- **Codecs:** `dev_codec_ans104`, `dev_codec_structured`, `dev_codec_cookie`, `dev_codec_httpsig`
- **HTTP Client:** `hb_http_client`, `hb_http_multi`
- **Arweave:** `ar_bundles`, `ar_wallet`
- **External:** `cowboy_req`, `httpc`
- **Includes:** `include/hb.hrl`

---

## Public Functions Overview

```erlang
%% Initialization
-spec start() -> ok.

%% Client Requests
-spec get(Node, Opts) -> {ok, Message} | {error, Reason}.
-spec get(Node, Path, Opts) -> {ok, Message} | {error, Reason}.
-spec get(Node, Message, Opts) -> {ok, Message} | {error, Reason}.

-spec post(Node, Path, Opts) -> {ok, Message} | {error, Reason}.
-spec post(Node, Message, Opts) -> {ok, Message} | {error, Reason}.
-spec post(Node, Path, Message, Opts) -> {ok, Message} | {error, Reason}.

%% Generic Request
-spec request(Message, Opts) -> {ok | created | error | failure, Result}.
-spec request(Method, Peer, Path, Opts) -> {ok | created | error | failure, Result}.
-spec request(Method, Peer, Path, Message, Opts) -> {ok | created | error | failure, Result}.

%% Message Conversion
-spec message_to_request(Message, Opts) -> {ok, Method, Peer, Path, Message, Opts}.

%% Server Processing
-spec reply(Request, StatusCode, Headers, Body) -> cowboy_req:req().
-spec accept_to_codec(Accept, Opts) -> CodecDevice.

%% Utilities
-spec req_to_tabm_singleton(Request, Message, Opts) -> Messages.
```

---

## Public Functions

### 1. start/0

```erlang
-spec start() -> ok.
```

**Description:** Initialize HTTP client by disabling keep-alive connections.

**Implementation:**
```erlang
start() ->
    httpc:set_options([{max_keep_alive_length, 0}]),
    ok.
```

---

### 2. get/2, get/3

```erlang
-spec get(Node, Opts) -> {ok, Message} | {error, Reason}
    when
        Node :: binary(),
        Opts :: map(),
        Message :: map(),
        Reason :: term().

-spec get(Node, PathOrMessage, Opts) -> {ok, Message} | {error, Reason}
    when
        Node :: binary(),
        PathOrMessage :: binary() | map(),
        Opts :: map(),
        Message :: map(),
        Reason :: term().
```

**Description:** Perform HTTP GET request to a remote node, returning deserialized message response.

**Test Code:**
```erlang
-module(hb_http_get_test).
-include_lib("eunit/include/eunit.hrl").

get_basic_test() ->
    URL = hb_http_server:start_node(),
    {ok, Res} = hb_http:get(URL, <<"/~meta@1.0/info">>, #{}),
    ?assert(is_map(Res)).

get_with_message_test() ->
    URL = hb_http_server:start_node(),
    Message = #{<<"path">> => <<"/key1">>, <<"key1">> => <<"Value1">>},
    {ok, Res} = hb_http:get(URL, Message, #{}),
    ?assert(is_map(Res)).

cors_get_test() ->
    URL = hb_http_server:start_node(),
    {ok, Res} = hb_http:get(URL, <<"/~meta@1.0/info">>, #{}),
    ?assertEqual(<<"*">>, hb_ao:get(<<"access-control-allow-origin">>, Res, #{})).
```

---

### 3. post/3, post/4

```erlang
-spec post(Node, PathOrMessage, Opts) -> {ok, Message} | {error, Reason}
    when
        Node :: binary(),
        PathOrMessage :: binary() | map(),
        Opts :: map(),
        Message :: map(),
        Reason :: term().

-spec post(Node, Path, Message, Opts) -> {ok, Message} | {error, Reason}
    when
        Node :: binary(),
        Path :: binary(),
        Message :: map(),
        Opts :: map(),
        Reason :: term().
```

**Description:** Post message to remote node via HTTP, returning deserialized response.

**Test Code:**
```erlang
-module(hb_http_post_test).
-include_lib("eunit/include/eunit.hrl").

simple_ao_resolve_unsigned_test() ->
    URL = hb_http_server:start_node(),
    TestMsg = #{<<"path">> => <<"/key1">>, <<"key1">> => <<"Value1">>},
    ?assertEqual({ok, <<"Value1">>}, hb_http:post(URL, TestMsg, #{})).

simple_ao_resolve_signed_test() ->
    URL = hb_http_server:start_node(),
    TestMsg = #{<<"path">> => <<"/key1">>, <<"key1">> => <<"Value1">>},
    Wallet = hb:wallet(),
    {ok, Res} = hb_http:post(URL, hb_message:commit(TestMsg, Wallet), #{}),
    ?assertEqual(<<"Value1">>, Res).

nested_ao_resolve_test() ->
    URL = hb_http_server:start_node(),
    Wallet = hb:wallet(),
    {ok, Res} = hb_http:post(
        URL,
        hb_message:commit(#{
            <<"path">> => <<"/key1/key2/key3">>,
            <<"key1">> => #{<<"key2">> => #{<<"key3">> => <<"Value2">>}}
        }, Wallet),
        #{}
    ),
    ?assertEqual(<<"Value2">>, Res).
```

---

### 4. request/2, request/4, request/5

```erlang
-spec request(Message, Opts) -> {Status, Result}
    when
        Message :: map(),
        Opts :: map(),
        Status :: ok | created | error | failure,
        Result :: term().

-spec request(Method, Peer, Path, Message, Opts) -> {Status, Result}
    when
        Method :: binary(),
        Peer :: binary() | map(),
        Path :: binary(),
        Message :: map(),
        Opts :: map(),
        Status :: ok | created | error | failure,
        Result :: term().
```

**Description:** Generic HTTP request handler supporting GET, POST, PUT, DELETE. Handles routing, multi-requests, codec selection, and response processing.

**Special Cases:**
- **Routes:** Delegates to `hb_http_multi` when `<<"nodes">>` present
- **URI Options:** Merges additional options from route configuration
- **AO-Result:** Returns single key value when `ao-result` header present

**Test Code:**
```erlang
-module(hb_http_request_test).
-include_lib("eunit/include/eunit.hrl").

run_wasm_unsigned_test() ->
    Node = hb_http_server:start_node(#{force_signed => false}),
    {ok, Bin} = file:read_file(<<"test/test-64.wasm">>),
    Msg = #{
        <<"path">> => <<"/init/compute/results">>,
        <<"device">> => <<"wasm-64@1.0">>,
        <<"function">> => <<"fac">>,
        <<"parameters">> => [3.0],
        <<"body">> => Bin
    },
    {ok, Res} = hb_http:post(Node, Msg, #{}),
    ?assertEqual(6.0, hb_ao:get(<<"output/1">>, Res, #{})).

run_wasm_signed_test() ->
    Opts = #{priv_wallet => hb:wallet()},
    URL = hb_http_server:start_node(#{force_signed => true}),
    {ok, Bin} = file:read_file(<<"test/test-64.wasm">>),
    Msg = hb_message:commit(#{
        <<"device">> => <<"wasm-64@1.0">>,
        <<"function">> => <<"fac">>,
        <<"parameters">> => [3.0],
        <<"body">> => Bin
    }, Opts),
    {ok, Res} = hb_http:post(URL, Msg#{ <<"path">> => <<"/init/compute/results">> }, Opts),
    ?assertEqual(6.0, hb_ao:get(<<"output/1">>, Res, #{})).

ans104_wasm_test() ->
    ClientOpts = #{store => [hb_test_utils:test_store()], priv_wallet => hb:wallet()},
    URL = hb_http_server:start_node(#{force_signed => true}),
    {ok, Bin} = file:read_file(<<"test/test-64.wasm">>),
    Msg = hb_message:commit(
        #{
            <<"require-codec">> => <<"ans104@1.0">>,
            <<"codec-device">> => <<"ans104@1.0">>,
            <<"device">> => <<"wasm-64@1.0">>,
            <<"function">> => <<"fac">>,
            <<"parameters">> => [3.0],
            <<"body">> => Bin
        },
        ClientOpts,
        #{<<"device">> => <<"ans104@1.0">>, <<"bundle">> => true}
    ),
    {ok, Res} = hb_http:post(URL, Msg#{<<"path">> => <<"/init/compute/results">>}, ClientOpts),
    ?assertEqual(6.0, hb_ao:get(<<"output/1">>, Res, ClientOpts)).
```

---

### 5. message_to_request/2

```erlang
-spec message_to_request(Message, Opts) -> {ok, Method, Peer, Path, Message, Opts}
    when
        Message :: map(),
        Opts :: map(),
        Method :: binary(),
        Peer :: binary(),
        Path :: binary().
```

**Description:** Convert HyperBEAM message to HTTP request components, extracting method, peer, path, and preparing message for transmission.

**Conversion Flow:**
```erlang
Message
    ↓
Extract Method (default: GET)
    ↓
Parse URL/Peer/Path
    ↓
Handle Query Parameters
    ↓
Prepare Message Body
    ↓
Return {ok, Method, Peer, Path, PreparedMessage, Opts}
```

---

### 6. reply/4

```erlang
-spec reply(Request, StatusCode, Headers, Body) -> cowboy_req:req()
    when
        Request :: cowboy_req:req(),
        StatusCode :: integer(),
        Headers :: map() | list(),
        Body :: binary().
```

**Description:** Send HTTP response to client via Cowboy, handling headers, status codes, and body serialization.

**Features:**
- Auto-detects content type from body
- Converts headers map to list format
- Handles binary and JSON bodies
- Sets appropriate CORS headers

---

### 7. accept_to_codec/2

```erlang
-spec accept_to_codec(Accept, Opts) -> CodecDevice
    when
        Accept :: binary() | undefined,
        CodecDevice :: binary().
```

**Description:** Convert HTTP Accept header to HyperBEAM codec device identifier.

**Mappings:**
```erlang
<<"application/octet-stream">> -> <<"ans104@1.0">>
<<"application/json">>         -> <<"structured@1.0">>
<<"text/plain">>               -> <<"structured@1.0">>
undefined                      -> <<"structured@1.0">>
```

---

### 8. req_to_tabm_singleton/3

```erlang
-spec req_to_tabm_singleton(Request, Message, Opts) -> Messages
    when
        Request :: cowboy_req:req(),
        Message :: map(),
        Opts :: map(),
        Messages :: [map()].
```

**Description:** Convert Cowboy request to HyperBEAM message sequence for singleton execution.

**Processing Steps:**
1. Extract HTTP method and path
2. Parse query parameters
3. Extract and normalize headers
4. Handle cookie parsing
5. Process request body based on content-type
6. Detect codec device from Accept header
7. Add peer information if `ao-peer-port` present

---

## Response Status Mapping

```erlang
response_status_to_atom(Status) ->
    case Status of
        201 -> created;
        X when X < 400 -> ok;
        X when X < 500 -> error;
        _ -> failure
    end.
```

**Status Categories:**
- `created` - HTTP 201
- `ok` - HTTP 2xx-3xx (except 201)
- `error` - HTTP 4xx (client errors)
- `failure` - HTTP 5xx (server errors)

---

## Codec Device Handling

### Outbound Requests

```erlang
% Detect codec from message or use default
CodecDev = hb_maps:get(<<"codec-device">>, Message, <<"httpsig@1.0">>, Opts),

% Prepare request based on codec
prepare_request(CodecDev, Method, Peer, Path, Message, Opts)
```

### Inbound Responses

```erlang
% Find codec from response headers
CodecDev = hb_maps:get(<<"codec-device">>, Headers, <<"httpsig@1.0">>, Opts),

% Convert response to message
outbound_result_to_message(CodecDev, Status, Headers, Body, Opts)
```

**Supported Codecs:**
- `httpsig@1.0` - HTTP Signature (default)
- `ans104@1.0` - ANS-104 data items
- `structured@1.0` - Structured messages
- `json@1.0` - JSON encoding

---

## Cookie Handling

### Set-Cookie Processing

```erlang
% Extract Set-Cookie headers from response
SetCookieLines = [{<<"set-cookie">>, KeyVal} || {<<"set-cookie">>, KeyVal} <- Headers],

% Convert to cookie message
{ok, MsgWithCookies} = dev_codec_cookie:from(
    #{<<"set-cookie">> => SetCookieLines},
    #{},
    Opts
),

% Merge into response headers
HeaderMap = hb_maps:merge(hb_maps:from_list(Headers), MsgWithCookies, Opts)
```

### Cookie Request Handling

```erlang
% Parse cookie from request
{ok, WithCookie} = case maps:get(<<"cookie">>, RawHeaders, undefined) of
    undefined -> {ok, BaseMsg};
    Cookie -> dev_codec_cookie:from(BaseMsg#{<<"cookie">> => Cookie}, Req, Opts)
end
```

---

## Common Patterns

```erlang
%% Simple GET request
{ok, Response} = hb_http:get(<<"http://node.example.com">>, <<"/path">>, #{}).

%% POST with message
Message = #{<<"key">> => <<"value">>},
{ok, Response} = hb_http:post(Node, <<"/endpoint">>, Message, #{}).

%% Signed POST request
Wallet = hb:wallet(),
SignedMsg = hb_message:commit(Message, #{priv_wallet => Wallet}),
{ok, Response} = hb_http:post(Node, SignedMsg, #{}).

%% Request with specific codec
Opts = #{<<"codec-device">> => <<"ans104@1.0">>},
{ok, Response} = hb_http:post(Node, Message, Opts).

%% Extract single result key
Opts = #{http_only_result => true},
Message = #{<<"path">> => <<"/data">>, <<"ao-result">> => <<"body">>},
{ok, BodyOnly} = hb_http:post(Node, Message, Opts).

%% Handle routes (multi-request)
Config = #{
    <<"nodes">> => [
        <<"http://node1.example.com">>,
        <<"http://node2.example.com">>
    ]
},
{ok, Response} = hb_http:request(<<"GET">>, Config, <<"/path">>, #{}, #{}).
```

---

## Configuration Options

```erlang
Opts = #{
    % HTTP client selection
    http_client => gun | httpc,  % Default: gun
    
    % Result extraction
    http_only_result => true | false,  % Default: true
    
    % Codec selection
    <<"codec-device">> => <<"httpsig@1.0">> | <<"ans104@1.0">> | <<"structured@1.0">>,
    
    % Wallet for signing
    priv_wallet => {PrivateKey, PublicKey},
    
    % Request timeout
    http_request_send_timeout => Milliseconds,
    
    % Response size limit
    limit => Bytes | infinity,
    
    % Peer identification
    is_peer_request => boolean(),
    
    % HTTP monitoring
    http_monitor => MonitorMessage,
    http_reference => ReferenceValue,
    
    % Cache control
    cache_control => [<<"no-cache">>, <<"no-store">>]
}.
```

---

## Error Handling

```erlang
% Client errors (4xx)
{error, Reason}

% Server errors (5xx)
{failure, Reason}

% Network errors
{error, client_error}
{error, connection_closed}
{error, timeout}

% Codec errors
{error, unsupported_codec}
{error, invalid_message}
```

---

## Server-Side Processing

### Request Normalization

```erlang
% Convert Cowboy request to HyperBEAM message
Messages = hb_http:req_to_tabm_singleton(Req, InitialMsg, Opts),

% Process through singleton
Results = hb_ao:resolve_many(Messages, Opts)
```

### Response Generation

```erlang
% Send response back to client
Reply = hb_http:reply(Req, 200, Headers, Body)
```

---

## Performance Notes

1. **Keep-Alive Disabled:** Connections don't persist between requests
2. **Parallel Requests:** Use `hb_http_multi` for concurrent node access
3. **Streaming:** Supports chunked transfer encoding via gun
4. **Metrics:** Records request duration in Prometheus when enabled
5. **Connection Pooling:** Managed by `hb_http_client` gen_server

---

## References

- **HTTP Client** - `hb_http_client.erl`
- **Multi-Request** - `hb_http_multi.erl`
- **Message System** - `hb_message.erl`, `hb_ao.erl`
- **Codecs** - `dev_codec_*.erl` modules
- **Server** - `hb_http_server.erl`

---

## Notes

1. **Default Codec:** `httpsig@1.0` used unless specified
2. **Message Signing:** Optional, controlled by wallet presence
3. **Cookie Support:** Full Set-Cookie and Cookie header processing
4. **CORS:** Automatic CORS headers on responses
5. **Query Parameters:** Extracted and added to message
6. **Path Resolution:** Supports nested path traversal in messages
7. **AO-Result:** Can extract single key from response for efficiency
8. **Peer Detection:** Honors `x-real-ip` for accurate peer address
9. **Body Streaming:** Large responses handled efficiently
10. **Status Normalization:** Consistent status atom mapping
11. **Multi-Gateway:** Seamless delegation to multi-request system
12. **Header Filtering:** Default filter for `content-length`
13. **Content-Type Detection:** Auto-detects from body or headers
14. **Accept Header:** Maps to appropriate codec device
15. **Monitoring:** Optional HTTP request monitoring via AO-Core